"""
LeetCode Problem #924: Minimize Malware Spread

URL: https://leetcode.com/problems/minimize-malware-spread/

You are given a network of n nodes, represented as an n x n adjacency matrix graph,
where the ith node is directly connected to the jth node if graph[i][j] == 1.

Some nodes initial are initially infected by malware. Whenever two nodes are directly
connected, and at least one of those two nodes is infected by malware, both nodes
will be infected by malware. This spread of malware will continue until no more
nodes can be infected in this manner.

Suppose M(initial) is the final number of nodes infected with malware in the entire
network after the spread of malware stops. We will remove exactly one node from
initial. Return the node that, if removed, would result in the final number of
infected nodes being minimized. If multiple nodes could be removed to minimize the
final number of infected nodes, return such a node with the smallest index.
"""
from typing import List


class Solution:
    """Solution for minimizing malware spread using Union-Find."""

    def minMalwareSpread(self, network_graph: List[List[int]], infected_nodes: List[int]) -> int:
        """
        Find the node to remove that minimizes malware spread.

        Uses Union-Find to group connected components, then determines which single
        infected node, when removed, would save the most nodes from infection.

        Args:
            network_graph: n x n adjacency matrix where graph[i][j] == 1 means
                         nodes i and j are directly connected
            infected_nodes: List of initially infected node indices

        Returns:
            Index of the node to remove to minimize final infection count.
            If multiple nodes minimize equally, returns the smallest index.

        Time Complexity: O(nÂ²) for building Union-Find structure
        Space Complexity: O(n) for Union-Find data structures
        """
        total_nodes = len(network_graph)
        component_size = [1] * total_nodes
        parent = list(range(total_nodes))

        def find_root(node_x: int) -> int:
            """
            Find root of component containing node_x with path compression.

            Args:
                node_x: Node to find root for

            Returns:
                Root node of the component
            """
            if parent[node_x] != node_x:
                parent[node_x] = find_root(parent[node_x])
            return parent[node_x]

        def union_components(node_x: int, node_y: int):
            """
            Union two components by connecting their roots.

            Args:
                node_x: First node to union
                node_y: Second node to union
            """
            root_x, root_y = find_root(node_x), find_root(node_y)
            if root_x == root_y:
                return
            # Ensure root_x is the larger component
            if component_size[root_x] < component_size[root_y]:
                root_x, root_y = root_y, root_x
            parent[root_y] = root_x
            component_size[root_x] += component_size[root_y]

        # Build connected components using Union-Find
        for i in range(total_nodes):
            for j in range(i + 1, total_nodes):
                if network_graph[i][j] == 1:
                    union_components(i, j)

        # Count infected nodes in each component and find optimal removal
        infection_counts = [0] * total_nodes
        for node in infected_nodes:
            infection_counts[find_root(node)] += 1

        # Find optimal node to remove
        result = min(infected_nodes)
        max_saved_nodes = -1
        for node in sorted(infected_nodes):
            root = find_root(node)
            # Only consider components with exactly one infected node
            if infection_counts[root] == 1 and component_size[root] > max_saved_nodes:
                result = node
                max_saved_nodes = component_size[root]
        return result



if __name__ == "__main__":
    # Example test case
    example_graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]
    example_initial = [0, 1]
    solution = Solution()
    print(solution.minMalwareSpread(example_graph, example_initial))  # Example usage
