"""
Comprehensive test suite for LeetCode Problem #924: Minimize Malware Spread

Tests the minMalwareSpread method which finds the optimal node to remove
to minimize the spread of malware through a network graph using Union-Find.
"""

from leetcode.minimize_malware_spread import Solution


class TestMinimizeMalwareSpread:
    """Test class for minimize malware spread problem."""

    def setup_method(self):
        """Set up test fixtures before each test method."""
        self.solution = Solution()

    def test_example_case_1(self):
        """Test LeetCode example case 1."""
        graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]
        initial = [0, 1]
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 0  # Removing node 0 saves the most nodes
        assert result == expected

    def test_example_case_2(self):
        """Test LeetCode example case 2."""
        graph = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        initial = [0, 2]
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 0  # Both nodes save 1 node each, choose smaller index
        assert result == expected

    def test_single_infected_node(self):
        """Test with single infected node."""
        graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]
        initial = [0]
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 0  # Only one option
        assert result == expected

    def test_all_nodes_connected(self):
        """Test with all nodes in single component."""
        graph = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
        initial = [0, 1]
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 0  # Since both are in same component, removing any doesn't help
        assert result == expected

    def test_completely_disconnected(self):
        """Test with completely disconnected nodes."""
        graph = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        initial = [0, 1, 2]
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 0  # All isolated, choose smallest index
        assert result == expected

    def test_large_component_vs_small(self):
        """Test choosing larger component to save."""
        # Component 1: nodes 0,1,2,3 (size 4)
        # Component 2: node 4 (size 1)
        graph = [
            [1, 1, 0, 0, 0],  # 0 connected to 1
            [1, 1, 1, 0, 0],  # 1 connected to 0,2
            [0, 1, 1, 1, 0],  # 2 connected to 1,3
            [0, 0, 1, 1, 0],  # 3 connected to 2
            [0, 0, 0, 0, 1]   # 4 isolated
        ]
        initial = [0, 4]  # Infect node 0 (component size 4) and node 4 (component size 1)
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 0  # Removing 0 saves 4 nodes, removing 4 saves 1 node
        assert result == expected

    def test_multiple_infections_same_component(self):
        """Test component with multiple infected nodes."""
        graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]
        initial = [0, 1, 2]  # Nodes 0 and 1 in same component
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 2  # Removing 2 saves its component, 0 and 1 are in same component
        assert result == expected

    def test_no_beneficial_removal(self):
        """Test when no removal helps (all in same component)."""
        graph = [[1, 1], [1, 1]]
        initial = [0, 1]
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 0  # Both in same component, choose smaller index
        assert result == expected

    def test_linear_chain_graph(self):
        """Test with linear chain of nodes."""
        # Chain: 0-1-2-3-4
        graph = [
            [1, 1, 0, 0, 0],  # 0 connected to 1
            [1, 1, 1, 0, 0],  # 1 connected to 0,2
            [0, 1, 1, 1, 0],  # 2 connected to 1,3
            [0, 0, 1, 1, 1],  # 3 connected to 2,4
            [0, 0, 0, 1, 1]   # 4 connected to 3
        ]
        initial = [0, 4]  # Infect endpoints
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 0  # Both save same amount, choose smaller index
        assert result == expected

    def test_star_graph(self):
        """Test with star graph (central node connected to all)."""
        # Star: center node 0 connected to 1,2,3
        graph = [
            [1, 1, 1, 1],  # 0 connected to all
            [1, 1, 0, 0],  # 1 connected to 0
            [1, 0, 1, 0],  # 2 connected to 0
            [1, 0, 0, 1]   # 3 connected to 0
        ]
        initial = [1, 2]  # Infect two leaf nodes
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 1  # Both save same amount, choose smaller index
        assert result == expected

    def test_return_type_and_constraints(self):
        """Test return type and basic constraints."""
        graph = [[1, 0], [0, 1]]
        initial = [0, 1]
        result = self.solution.minMalwareSpread(graph, initial)
        
        assert isinstance(result, int)
        assert result in initial
        assert 0 <= result < len(graph)

    def test_algorithm_correctness_brute_force_comparison(self):
        """Test algorithm correctness by comparing with brute force approach."""
        def count_infected_after_removal(graph, initial, remove_node):
            """Count total infected nodes after removing one node."""
            # Simulate DFS spread without the removed node
            infected = set(initial) - {remove_node}
            if not infected:
                return 0
                
            # Keep spreading until no more changes
            changed = True
            while changed:
                changed = False
                new_infected = set(infected)
                for i in infected:
                    for j in range(len(graph)):
                        if graph[i][j] == 1 and j not in infected and j != remove_node:
                            new_infected.add(j)
                            changed = True
                infected = new_infected
            return len(infected)
        
        def brute_force_solution(graph, initial):
            """Brute force solution for comparison."""
            min_infected = float('inf')
            result = min(initial)
            
            for remove_candidate in sorted(initial):
                infected_count = count_infected_after_removal(graph, initial, remove_candidate)
                if infected_count < min_infected:
                    min_infected = infected_count
                    result = remove_candidate
                elif infected_count == min_infected and remove_candidate < result:
                    result = remove_candidate
            
            return result
        
        test_cases = [
            ([[1, 1, 0], [1, 1, 0], [0, 0, 1]], [0, 1]),
            ([[1, 0, 0], [0, 1, 0], [0, 0, 1]], [0, 2]),
            ([[1, 1, 1], [1, 1, 1], [1, 1, 1]], [0, 1]),
        ]
        
        for graph, initial in test_cases:
            union_find_result = self.solution.minMalwareSpread(graph, initial)
            brute_force_result = brute_force_solution(graph, initial)
            assert union_find_result == brute_force_result, f"Mismatch for graph {graph}, initial {initial}"

    def test_edge_case_empty_initial(self):
        """Test edge case behavior (though not valid per constraints)."""
        graph = [[1, 0], [0, 1]]
        initial = []
        try:
            result = self.solution.minMalwareSpread(graph, initial)
            # If it doesn't crash, result should be meaningful
            assert isinstance(result, int)
        except (ValueError, IndexError):
            # Acceptable to fail on invalid input
            pass

    def test_complex_graph_structure(self):
        """Test with more complex graph structure."""
        # Two components: {0,1,2} and {3,4,5}
        graph = [
            [1, 1, 1, 0, 0, 0],  # 0 in component 1
            [1, 1, 1, 0, 0, 0],  # 1 in component 1
            [1, 1, 1, 0, 0, 0],  # 2 in component 1
            [0, 0, 0, 1, 1, 1],  # 3 in component 2
            [0, 0, 0, 1, 1, 1],  # 4 in component 2
            [0, 0, 0, 1, 1, 1]   # 5 in component 2
        ]
        initial = [0, 3]  # One infection in each component
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 0  # Both components same size, choose smaller index
        assert result == expected

    def test_mixed_component_sizes(self):
        """Test with components of different sizes."""
        # Component 1: {0,1} (size 2)
        # Component 2: {2,3,4,5} (size 4)
        # Component 3: {6} (size 1)
        graph = [
            [1, 1, 0, 0, 0, 0, 0],  # 0-1
            [1, 1, 0, 0, 0, 0, 0],  # 1-0
            [0, 0, 1, 1, 1, 1, 0],  # 2-3,4,5
            [0, 0, 1, 1, 1, 1, 0],  # 3-2,4,5
            [0, 0, 1, 1, 1, 1, 0],  # 4-2,3,5
            [0, 0, 1, 1, 1, 1, 0],  # 5-2,3,4
            [0, 0, 0, 0, 0, 0, 1]   # 6 isolated
        ]
        initial = [1, 2, 6]  # Infect one node in each component
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 2  # Removing 2 saves 4 nodes (largest component)
        assert result == expected

    def test_performance_larger_graph(self):
        """Test performance with larger graph."""
        import time
        
        # Create larger graph: 20 nodes in single component
        n = 20
        graph = [[0] * n for _ in range(n)]
        for i in range(n):
            graph[i][i] = 1  # Self-loop
            if i < n - 1:
                graph[i][i + 1] = 1  # Connect to next
                graph[i + 1][i] = 1  # Bidirectional
        
        initial = [0, 5, 10, 15]
        
        start_time = time.time()
        result = self.solution.minMalwareSpread(graph, initial)
        end_time = time.time()
        
        # Should complete quickly
        assert end_time - start_time < 1.0
        assert result in initial

    def test_union_find_correctness(self):
        """Test that Union-Find correctly identifies components."""
        # Create graph with known components
        graph = [
            [1, 1, 0, 0],  # Component 1: {0,1}
            [1, 1, 0, 0],
            [0, 0, 1, 1],  # Component 2: {2,3}
            [0, 0, 1, 1]
        ]
        initial = [0, 2]  # One infection per component
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 0  # Both components same size, choose smaller index
        assert result == expected

    def test_mathematical_properties(self):
        """Test mathematical properties of the solution."""
        graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]
        initial = [0, 1, 2]
        result = self.solution.minMalwareSpread(graph, initial)
        
        # Result should be in initial set
        assert result in initial
        
        # Should be minimal element when ties exist
        assert result == min([node for node in initial if node == result])

    def test_boundary_cases(self):
        """Test boundary cases."""
        # Minimum graph size
        graph = [[1]]
        initial = [0]
        result = self.solution.minMalwareSpread(graph, initial)
        assert result == 0
        
        # Two-node cases
        graph = [[1, 1], [1, 1]]
        initial = [0, 1]
        result = self.solution.minMalwareSpread(graph, initial)
        assert result == 0  # Choose smaller when equal impact

    def test_algorithm_stability(self):
        """Test that algorithm produces consistent results."""
        graph = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]
        initial = [0, 1]
        
        # Run multiple times
        results = [self.solution.minMalwareSpread(graph, initial) for _ in range(5)]
        
        # All results should be identical
        assert all(result == results[0] for result in results)

    def test_symmetric_graph_properties(self):
        """Test behavior on symmetric graphs."""
        # Symmetric graph where all initial nodes have equal impact
        graph = [
            [1, 0, 0, 1],  # 0 connects to 3
            [0, 1, 0, 1],  # 1 connects to 3
            [0, 0, 1, 1],  # 2 connects to 3
            [1, 1, 1, 1]   # 3 connects to all
        ]
        initial = [0, 1, 2]  # All non-central nodes
        result = self.solution.minMalwareSpread(graph, initial)
        expected = 0  # Should choose smallest index when equal benefit
        assert result == expected
